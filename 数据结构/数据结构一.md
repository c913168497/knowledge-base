 

### 线性结构
 
数据结构我们可以从逻辑上分为线性结构和非线性结构。线性结构有数组，栈，链表等， 非线性结构有树，图等。
需要注意的是，线性和非线性不代表存储结构是线性的还是非线性的，这两者没有任何关系，它只是一种逻辑上的划分。比如我们可以用数组去存储二叉树。一般而言，有前驱和后继的就是线性数据结构。比如数组和链表。
 
### 数组
 
其实后面的数据结构很多都有数组的影子。数组是最简单的数据结构了，很多地方都用到它。 比如用一个数据列表存储一些用户的 id，就可以用数组进行存储。

栈和队列其实都可以看成是一种受限的数组，怎么个受限法呢？我们后面讨论。
接下来通过几个有趣的例子来加深大家对数组这种数据结构的理解。

### 队列
 
队列是一种受限的序列。受限在哪呢？受限就受限在它只能够操作队尾和队首，并且只能只能在队尾添加元素，在队首删除元素。而数组就没有这个限制。
队列作为一种最常见的数据结构同样有着非常广泛的应用， 比如消息队列
"队列"这个名称，可类比为现实生活中排队（不插队的那种）
在计算机科学中，一个 队列 (queue) 是一种特殊类型的抽象数据类型或集合，集合中的实体按顺序保存。
队列基本操作有两种：
向队列的后端位置添加实体，称为入队
从队列的前端位置移除实体，称为出队。
队列中元素先进先出 FIFO (first in, first out) 的示意：
 
![image.png](http://note.youdao.com/yws/res/5519/WEBRESOURCE3ae812e0551786bb9ec3d5d91c20f170)

 
我们在做性能优化的时候，很多时候会提到的一点就是“HTTP 1.1 的队头阻塞问题”，具体来说就是 HTTP2 解决了 HTTP1.1 中的队头阻塞问题，但是为什么 HTTP1.1 有队头阻塞问题，HTTP2 究竟怎么解决的这个问题，很多人都不清楚。
 
其实队头阻塞是一个专有名词，不仅仅在 HTTP 有，交换器等其他地方也都涉及到了这个问题。实际上引起这个问题的根本原因是使用了队列这种数据结构。
 
协议规定， 对于同一个 tcp 连接，所有的 http1.0 请求放入队列中，只有前一个请求的响应收到了，才能发送下一个请求，这个时候就发生了阻塞，并且这个阻塞主要发生在客户端。
 
这就好像我们在等红绿灯，即使旁边绿灯亮了，你的这个车道是红灯，你还是不能走，还是要等着。
 

#### HTTP/1.0 和 HTTP/1.1:
 
在HTTP/1.0 中每一次请求都需要建立一个 TCP 连接，请求结束后立即断开连接。
 

 
在HTTP/1.1 中，每一个连接都默认是长连接 (persistent connection)。对于同一个 tcp 连接，允许一次发送多个 http1.1 请求，也就是说，不必等前一个响应收到，就可以发送下一个请求。
 

 
这样就解决了 http1.0 的客户端的队头阻塞，而这也就是HTTP/1.1中管道 (Pipeline)的概念了。
 
 
但是，http1.1 规定，服务器端的响应的发送要根据请求被接收的顺序排队，也就是说，先接收到的请求的响应也要先发送。
 

 
这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送，这也会造成队头阻塞。可见，http1.1 的队首阻塞是发生在服务器端。
 

#### HTTP/2 和 HTTP/1.1
 
为了解决HTTP/1.1中的服务端队首阻塞，HTTP/2采用了二进制分帧 和 多路复用 等方法。
 

 
帧是HTTP/2数据通信的最小单位。在 HTTP/1.1 中数据包是文本格式，而 HTTP/2 的数据包是二进制格式的，也就是二进制帧。
 

 
采用帧的传输方式可以将请求和响应的数据分割得更小，且二进制协议可以被高效解析。
 

 
HTTP/2中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。
 

 
每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。
 

 
多路复用用以替代原来的序列和拥塞机制。
 

 
在HTTP/1.1中，并发多个请求需要多个 TCP 链接，且单个域名有 6-8 个 TCP 链接请求限制（这个限制是浏览器限制的，不同的浏览器也不一定一样）。
 

 
在HTTP/2中，同一域名下的所有通信在单个链接完成，仅占用一个 TCP 链接，且在这一个链接上可以并行请求和响应，互不干扰
 

### 栈
 
栈也是一种受限的序列，它受限就受限在只能够操作栈顶，不管入栈还是出栈，都是在栈顶操作。同样地，数组就没有这个限制。
 

 
在计算机科学中，一个栈 (stack) 是一种抽象数据类型，用作表示元素的集合，具有两种主要操作：
 

 
push, 添加元素到栈的顶端（末尾）
 

 
pop, 移除栈最顶端（末尾）的元素
 

 
以上两种操作可以简单概括为后进先出 (LIFO = last in, first out)。
 

 
此外，应有一个 peek
 

 
操作用于访问栈当前顶端（末尾）的元素。（只返回不弹出）
"栈"这个名称，可类比于一组物体的堆叠（一摞书，一摞盘子之类的）。
 

 
栈的 push 和 pop 操作的示意：

![image.png](http://note.youdao.com/yws/res/5539/WEBRESOURCE19dc9bc298aca8b96512a86aca4f2b5e)


### 链表
 
链表分为单链表和双向链表
 

 
1.单链表:每个节点包含两部分,一部分存放数据变量的data,另一部分是指向下一节点的next指针
 

 
2.双向链表:除了包含单链表的部分,还增加的pre前一个节点的指针
 

 
链表的优点在于,不需要连续的存储单元,修改链表的复杂度为O(1)
 

 
(在不考虑查找时)
但是缺点也很明显:无法直接找到指定节点,只能从头节点一步一步寻找复杂度为O(n)
 

![image.png](http://note.youdao.com/yws/res/5547/WEBRESOURCEb40e1730cae1f7ec28aebb6cd03bb16a)

### 非线性结构
 
那么有了线性结构，我们为什么还需要非线性结构呢？
 

 
答案是为了高效地兼顾静态操作和动态操作，我们一般使用树去管理需要大量动态操作的数据。大家可以对照各种数据结构的各种操作的复杂度来直观感受一下。
 
#### 树
 
树的应用同样非常广泛，小到文件系统，大到因特网，组织架构等都可以表示为树结构，而在我们前端眼中比较熟悉的 DOM 树也是一种树结构，而 HTML 作为一种 DSL 去描述这种树结构的具体表现形式。
 

 
如果你接触过 AST，那么 AST 也是一种树，XML 也是树结构。树的应用远比大多数人想象的要多得多。
 

 
树其实是一种特殊的图，是一种无环连通图，是一种极大无环图，也是一种极小连通图。
 

 
从另一个角度看，树是一种递归的数据结构。而且树的不同表示方法，比如不常用的长子 + 兄弟法，对于 你理解树这种数据结构有着很大用处， 说是一种对树的本质的更深刻的理解也不为过。
 

 
树的基本算法有前中后序遍历和层次遍历，有的同学对前中后这三个分别具体表现的访问顺序比较模糊，其实当初我也是一样的，后面我学到了一点，你只需要记住：所谓的前中后指的是根节点的位置，其他位置按照先左后右排列即可。比如前序遍历就是根左右, 中序就是左根右，后序就是左右根， 很简单吧？
 

 
我刚才提到了树是一种递归的数据结构，因此树的遍历算法使用递归去完成非常简单，幸运的是树的算法基本上都要依赖于树的遍历。
 

 
但是递归在计算机中的性能一直都有问题，因此掌握不那么容易理解的"命令式地迭代"遍历算法在某些情况下是有用的。如果你使用迭代式方式去遍历的话，可以借助上面提到的栈来进行，可以极大减少代码量。
 

 
如果使用栈来简化运算，由于栈是 FILO 的，因此一定要注意左右子树的推入顺序。
 

##### 树的重要性质：
 
如果树有 n 个顶点，那么其就有 n - 1 条边，这说明了树的顶点数和边数是同阶的。
 

 
任何一个节点到根节点存在唯一路径，路径的长度为节点所处的深度
 

 
实际使用的树有可能会更复杂，比如使用在游戏中的碰撞检测可能会用到四叉树或者八叉树。以及 k 维的树结构 k-d 树等。
 

![image.png](http://note.youdao.com/yws/res/5559/WEBRESOURCEcb487000d031e53dd0abe848a6410c24)

### 二叉树
 
二叉树是节点度数不超过二的树，是树的一种特殊子集，
 

 
有趣的是二叉树这种被限制的树结构却能够表示和实现所有的树， 它背后的原理正是长子 + 兄弟法，用邓老师的话说就是二叉树是多叉树的特例，但在有根且有序时，其描述能力却足以覆盖后者。
 

 
实际上， 在你使用长子 + 兄弟法表示树的同时，进行 45 度角旋转即可
 

  一个典型的二叉树：  

![image.png](http://note.youdao.com/yws/res/5566/WEBRESOURCE9ba416e0be0dac082fba59ef6bfff21a)

 
对于一般的树，我们通常会去遍历，这里又会有很多变种。
 

 
二叉树遍历的相关算法：
 

- 94.binary-tree-inorder-traversal
- binary-tree-level-order-traversal
- binary-tree-zigzag-level-order-traversal
- binary-tree-preorder-traversal
- binary-tree-postorder-traversal
- binary-tree-right-side-view

 
相关概念：
 
真二叉树 （所有节点的度数只能是偶数，即只能为 0 或者 2）


#### 堆
 
堆其实是一种优先级队列，在很多语言都有对应的内置数据结构
 

 
堆的一种典型的实现就是二叉堆。
 

##### 二叉堆的特点：
 
在一个 最小堆 (min heap) 中，如果 P 是 C 的一个父级节点，那么 P 的 key（或 value) 应小于或等于 C 的对应值。
 

 
正因为此，堆顶元素一定是最小的，我们会利用这个特点求最小值或者第 k 小的值。
 

![image.png](http://note.youdao.com/yws/res/5587/WEBRESOURCEf127e27ffde44e2fdf55997cf65c8370)

 
在一个 最大堆 (max heap) 中，P 的 key（或 value) 大于或等于 C 的对应值。
 


![image.png](http://note.youdao.com/yws/res/5591/WEBRESOURCE128a83d03d9d9208c24bce13d6c62abc)

   
需要注意的是优先队列不仅有堆一种，还有更复杂的，
但是通常来说，我们会把两者做等价。
   

相关算法：
- 295.find-median-from-data-stream

#### 二叉查找树
 
二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。
 

   
二叉查找树具有下列性质的二叉树：
   
- 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若右子树不空，则右子树上所有节点的值均大于它的根节点的值；
- 左、右子树也分别为二叉排序树；
没有键值相等的节点。

   
对于一个二叉查找树，常规操作有插入，查找，删除，
找父节点，求最大值，求最小值。
   

 
二叉查找树，之所以叫查找树就是因为其非常适合查找。
 

 
举个例子，如下一颗二叉查找树，我们想找节点值小于且最接近 58 的节点，搜索的流程如图所示：
 

![image.png](http://note.youdao.com/yws/res/5606/WEBRESOURCEf21c0c03bdeb9e52414aeebeb720f9a0)

 
另外我们二叉查找树有一个性质是：
 
   
其中序遍历的结果是一个有序数组。 有时候我们可以利用到这个性质。
   
相关算法:
- 98.validate-binary-search-tree

#### 二叉平衡树
 
平衡树是计算机科学中的一类数据结构，是一种改进的二叉查找树。
 

 
一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。
 

 
为了实现更高效的查询，产生了平衡树。
 

 
在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。
 

 
一些数据库引擎内部就是用的这种数据结构，其目标也是将查询的操作降低到 logn（树的深度），可以简单理解为树在数据结构层面构造了二分查找算法。
 
##### 基本操作：
- 旋转
- 插入
- 删除
- 查询前驱
- 查询后继

##### AVL
   
是最早被发明的自平衡二叉查找树。
在 AVL 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为高度平衡树。

查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。

增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。

AVL 树得名于它的发明者 G. M. Adelson-Velsky 和 Evgenii Landis，
他们在 1962 年的论文 An algorithm for the organization of information 中公开了这一数据结构。

节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。

带有平衡因子 1、0 或 -1 的节点被认为是平衡的。

带有平衡因子 -2 或 2 的节点被认为是不平衡的，并需要重新平衡这个树。

平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。
   

##### 红黑树
   
在 1972 年由鲁道夫·贝尔发明，被称为"对称二叉 B 树"，
它现代的名字源于 Leo J. Guibas 和 Robert Sedgewick 于 1978 年写的一篇论文。

红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：

它可以在 O(logn) 时间内完成查找，插入和删除，这里的 n 是树中元素的数目
   

##### 字典树（前缀树）
   
又称 Trie 树，是一种树形结构。
典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。
它的优点是：利用字符串的公共前缀来减少查询时间，
最大限度地减少无谓的字符串比较，查询效率比哈希树高。
   

![image.png](http://note.youdao.com/yws/res/5634/WEBRESOURCE9e4eae1dba6183f1b20a449c73a820d8)


- 根节点不包含字符，除根节点外每一个节点都只包含一个字符；
- 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；
- 每个节点的所有子节点包含的字符都不相同。

##### 相关算法
- 208.implement-trie-prefix-tree
- 211.add-and-search-word-data-structure-design
- 212.word-search-ii


### 图

前面讲的数据结构都可以看成是图的特例。
前面提到了二叉树完全可以实现其他树结构，其实有向图也完全可以实现无向图和混合图，因此有向图的研究一直是重点考察对象。



图论〔Graph Theory〕是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。



我们知道，前面讨论的数据结构都有一个框架，而这个框架是由相应的算法实现的，比如二叉树搜索树，左子树上所有结点的值均小于它的根结点的值，右子树所有结点的值均大于它的根节点的值，类似这种形状使得它容易搜索数据和插入数据，树的边表示了从一个节点到另一个节点的快捷方式。


 
而图通常有个固定的形状，这是由物理或抽象的问题所决定的。比如图中节点表示城市，而边可能表示城市间的班机航线。如下图是美国加利福利亚简化的高速公路网：
 

#### 基本概念
- 无向图 & 有向图
- 有权图 & 无权图
- 入度 & 出度
- 路径 & 环
- 连通图 & 强连通图


![image.png](http://note.youdao.com/yws/res/5693/WEBRESOURCEdf326821af09fc55c85c2caacb547300)

##### 邻接
   
如果两个顶点被同一条边连接，就称这两个顶点是邻接的
，如上图 I 和 G 就是邻接的，而 I 和 F 就不是。
有时候也将和某个指定顶点邻接的顶点叫做它的邻居，
比如顶点 G 的邻居是 I、H、F。
   
##### 路径
   
路径是边的序列，比如从顶点B到顶点J的路径为 BAEJ，当然还有别的路径 BCDJ，BACDJ等等。
   
##### 连通图和非连通图：
   
如果至少有一条路径可以连接起所有的顶点，那么这个图称作连通的；
如果假如存在从某个顶点不能到达另外一个顶点，则称为非联通的。
   
![image.png](http://note.youdao.com/yws/res/5701/WEBRESOURCEb8a0d2a1a8a8f65859e99b572ad63f17)

##### 有向图与无向图

   
如果图中的边没有方向，可以从任意一边到达另一边，则称为无向图；
比如双向高速公路，A城市到B城市可以开车从A驶向B，也可以开车从B城市驶向A城市。

但是如果只能从A城市驶向B城市的图，那么则称为有向图。

在无向图中，若任意两个顶点 i 与 j 都有路径相通，则称该无向图为连通图。

在有向图中，若任意两个顶点 i 与 j 都有路径相通，则称该有向图为强连通图。
   

##### 有权图和无权图
   
图中的边被赋予一个权值，权值是一个数字，
它能代表两个顶点间的物理距离，
或者从一个顶点到另一个顶点的时间，这种图被称为有权图；
反之边没有赋值的则称为无权图。

##### 在程序中表示图
我们知道图是由顶点和边组成，那么在计算机中，怎么来模拟顶点和边？

- 顶点

在大多数情况下，顶点表示某个真实世界的对象，这个对象必须用数据项来描述。<br>
比如在一个飞机航线模拟程序中，顶点表示城市，那么它需要存储城市的名字、海拔高度、地理位置和其它相关信息。<br>
因此通常用一个顶点类的对象来表示一个顶点，这里我们仅仅在顶点中存储了一个字母来标识顶点，同时还有一个标志位，用来判断该顶点有没有被访问过（用于后面的搜索）。

顶点对象能放在数组中，然后用下标指示，也可以放在链表或其它数据结构中，不论使用什么结构，存储只是为了使用方便，这与边如何连接点是没有关系的。

- 边：

在前面讲解各种树的数据结构时，大多数树都是每个节点包含它的子节点的引用，比如红黑树、二叉树。也有用数组表示树，树组中节点的位置决定了它和其它节点的关系，比如堆就是用数组表示。

然而图并不像树，图没有固定的结构，图的每个顶点可以与任意多个顶点相连，为了模拟这种自由形式的组织结构，用如下两种方式表示图：邻接矩阵和邻接表（如果一条边连接两个顶点，那么这两个顶点就是邻接的）

![image.png](http://note.youdao.com/yws/res/5729/WEBRESOURCE7fcdddcd4b4198ea89a274e26ec9b4e1)

##### 邻接矩阵

邻接矩阵是一个二维数组，数据项表示两点间是否存在边，如果图中有 N 个顶点，邻接矩阵就是 N*N 的数组。上图用邻接矩阵表示如下：

![image.png](http://note.youdao.com/yws/res/5737/WEBRESOURCEf5afa1e5c43d443a66e21cccc89fd055)

1表示有边，0表示没有边，也可以用布尔变量true和false来表示。

顶点与自身相连用 0 表示，所以这个矩阵从左上角到右上角的对角线全是 0 。

注意：这个矩阵的上三角是下三角的镜像，两个三角包含了相同的信息，这个冗余信息看似低效

但是在大多数计算机中，创造一个三角形数组比较困难，所以只好接受这个冗余，这也要求在程序处理中

当我们增加一条边时，比如更新邻接矩阵的两部分，而不是一部分。

##### 邻接表：
邻接表是一个链表数组（或者是链表的链表），每个单独的链表表示了有哪些顶点与当前顶点邻接。
![image.png](http://note.youdao.com/yws/res/5747/WEBRESOURCE40a3e3624923253a896181018b0c2b88)

##### 搜索 
在图中实现最基本的操作之一就是搜索从一个指定顶点可以到达哪些顶点，

比如从武汉出发的高铁可以到达哪些城市，一些城市可以直达，一些城市不能直达。

现在有一份全国高铁模拟图，

要从某个城市（顶点）开始，沿着铁轨（边）移动到其他城市（顶点），

有两种方法可以用来搜索图：深度优先搜索（DFS）和广度优先搜索（BFS）。

它们最终都会到达所有连通的顶点，深度优先搜索通过栈来实现，
而广度优先搜索通过队列来实现，不同的实现机制导致不同的搜索方式。

- 深度优先搜索（DFS）

深度优先搜索算法有如下规则：

规则1：如果能访问一个邻接的未访问顶点时，标记它，并将它放入栈中。

规则2：当不能执行规则 1 时，如果栈不为空，就从栈中弹出一个顶点。

规则3：如果不能执行规则 1 和规则 2 时，就完成了整个搜索过程。
![image.png](http://note.youdao.com/yws/res/5765/WEBRESOURCE95934b1c4f8119df1bb573bf4e7f0ea8)

对于上图，应用深度优先搜索如下：

假设选取 A 顶点为起始点，并且按照字母优先顺序进行访问，那么应用规则 1 ，接下来访问顶点 B，然后标记它，并将它放入栈中；

再次应用规则 1，接下来访问顶点 F，再次应用规则 1，访问顶点 H。

我们这时候发现，没有 H 顶点的邻接点了，这时候应用规则 2，从栈中弹出 H，这时候回到了顶点 F，但是我们发现 F 也除了 H 也没有与之邻接且未访问的顶点了，那么再弹出 F，这时候回到顶点 B，

同理规则 1 应用不了，应用规则 2，弹出 B，这时候栈中只有顶点 A了，然后 A 还有未访问的邻接点，所有接下来访问顶点 C，但是 C又是这条线的终点，所以从栈中弹出它，再次回到 A，

接着访问 D,G,I，最后也回到了 A，然后访问 E，但是最后又回到了顶点 A，这时候我们发现 A没有未访问的邻接点了，所以也把它弹出栈。

现在栈中已无顶点，于是应用规则 3，完成了整个搜索过程。

深度优先搜索在于能够找到与某一顶点邻接且没有访问过的顶点。这里以邻接矩阵为例，找到顶点所在的行，从第一列开始向后寻找值为1的列；列号是邻接顶点的号码，检查这个顶点是否未访问过，如果是这样，那么这就是要访问的下一个顶点，如果该行没有顶点既等于1（邻接）且又是未访问的，那么与指定点相邻接的顶点就全部访问过了（后面会用算法实现）。

- 广度优先搜索（BFS）

深度优先搜索要尽可能的远离起始点，而广度优先搜索则要尽可能的靠近起始点，它首先访问起始顶点的所有邻接点，然后再访问较远的区域，这种搜索不能用栈实现，而是用队列实现。

规则1：访问下一个未访问的邻接点（如果存在），这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中。

规则2：如果已经没有未访问的邻接点而不能执行规则 1 时，那么从队列列头取出一个顶点（如果存在），并使其成为当前顶点。

规则3：如果因为队列为空而不能执行规则 2，则搜索结束。

![image.png](http://note.youdao.com/yws/res/5765/WEBRESOURCE95934b1c4f8119df1bb573bf4e7f0ea8)
　　


对于上面的图，应用广度优先搜索：以A为起始点，首先访问所有与 A 相邻的顶点，并在访问的同时将其插入队列中，现在已经访问了 A,B,C,D和E。这时队列（从头到尾）包含 BCDE，已经没有未访问的且与顶点 A 邻接的顶点了，所以从队列中取出B，寻找与B邻接的顶点，这时找到F，所以把F插入到队列中。已经没有未访问且与B邻接的顶点了，所以从队列列头取出C，它没有未访问的邻接点。因此取出 D 并访问 G，D也没有未访问的邻接点了，所以取出E，现在队列中有 FG，在取出 F，访问 H，然后取出 G，访问 I，现在队列中有 HI，当取出他们时，发现没有其它为访问的顶点了，这时队列为空，搜索结束。

- 最小生成树
对于图的操作，还有一个最常用的就是找到最小生成树，最小生成树就是用最少的边连接所有顶点。对于给定的一组顶点，可能有很多种最小生成树，但是最小生成树的边的数量 E 总是比顶点 V 的数量小1，即：

　　V = E + 1

　　这里不用关心边的长度，不是找最短的路径（会在带权图中讲解），而是找最少数量的边，可以基于深度优先搜索和广度优先搜索来实现。

　　比如基于深度优先搜索，我们记录走过的边，就可以创建一个最小生成树。因为DFS 访问所有顶点，但只访问一次，它绝对不会两次访问同一个顶点，但她看到某条边将到达一个已访问的顶点，它就不会走这条边，它从来不遍历那些不可能的边，因此，DFS 算法走过整个图的路径必定是最小生成树。